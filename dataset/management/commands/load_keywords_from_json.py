import json
from django.core.management.base import BaseCommand, CommandError
from django.core.exceptions import ValidationError
from django.db import transaction

from project.utils import Logger
from dataset.models import Dataset, Keyword


class Command(BaseCommand):
	help = 'Load the keywords from a JSON file generated by the script extract_keywords_from_fits'
	
	def add_arguments(self, parser):
		parser.add_argument('dataset', help='The name of the dataset')
		parser.add_argument('json_file_path', metavar='JSONFILE', help='The path to the JSON file')
		parser.add_argument('--update', action='store_true', help='If a keyword already exists, update it')
		
	def handle(self, **options):
		# Create a logger
		self.log = Logger(self, options.get('verbosity', 2))
		
		# Get the dataset
		try:
			dataset = Dataset.objects.get(name = options['dataset'])
		except Dataset.DoesNotExist:
			raise CommandError('Dataset %s not found' % options['dataset'])
		
		# Get the content of the JSON file
		try:
			with open(options['json_file_path'], 'rt', encoding = 'UTF-8') as file:
				json_string = file.read()
		except IOError as why:
			raise CommandError('Could not read file %s: %s' % (options['json_file_path'], why)) from why
		
		# Parse the content of the JSON file
		keywords = self.get_keywords(json_string, dataset)
		
		# Save the keywords
		self.save_keywords(keywords.values(), options['update'])
	
	def get_keywords(self, json_string, dataset):
		'''Parse and check the keyword informations from A JSON file'''
		try:
			keyword_infos = json.loads(json_string)
		except json.JSONDecodeError as why:
			raise CommandError('Could not parse JSON string: %s' % why) from why
		
		# Convert the keyword_infos into a dict of Keyword instances
		keywords = dict()
		
		for keyword_info in keyword_infos:
			keyword = Keyword(dataset = dataset, **keyword_info)
			
			if not keyword.name:
				raise CommandError('Keyword name is missing in info %s' % keyword_info)
			elif keyword.name in keywords:
				raise CommandError('Duplicate keyword name %s' % keyword.name)
			else:
				try:
					keyword.full_clean(validate_unique=False)
				except ValidationError as why:
					raise CommandError('Keyword info is invalid: %s' % why) from why
				else:
					keywords[keyword.name] = keyword
		
		return keywords
	
	@transaction.atomic
	def save_keywords(self, keywords, update = False):
		'''Save the keywords into the DB in a transaction so that if there is a problem nothing is modified'''
		
		for keyword in keywords:
			
			# If it is OK to update, check if the keyword does not aleady exists
			if update:
				try:
					keyword.pk = Keyword.objects.get(dataset = keyword.dataset, name = keyword.name).pk
				except Keyword.DoesNotExist:
					keyword.pk = None
			
			# Save the keyword
			try:
				keyword.save()
			except Exception as why:
				raise CommandError('Could not save keyword %s: %s' % (keyword, why)) from why
			else:
				self.log.info('Saved keyword %s', keyword)
